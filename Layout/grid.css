/* css grid layout */
/* The CSS grid layout module excels at dividing a page into major regions or defining the relationship in terms of size, position, and layer, between parts of a control built from HTML primitives. */
/* Like tables, grid layout enables an author to align elements into columns and rows. For example, a grid container's child elements could position themselves so they actually overlap and layer, similar to CSS positioned elements. */


.wrapper{
    margin: 10px auto;
    text-align: center;
    max-width: 700px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    grid-auto-rows: minmax(100px , auto);
    border: 2px solid black;
    padding: 15px;
  }
  
  .wrapper > div{
    background-color: honeydew;
    border: 2px dotted black;
  }

  
/* Layering items with z-index */
/* Grid items can occupy the same cell, and in this case we can use the z-index property to control the order in which overlapping items stack. */
/* Controlling the order
We can control the order in which items stack up by using the z-index property - just like positioned items. If we give box2 a lower z-index than box1 it will display below box1 in the stack. */

.one{
    grid-column: 1 / 3;
    grid-row: 1;
    z-index: 1;
  }
  .Two{
    grid-column: 2 / 4;
    grid-row: 1 / 3;
    z-index: 2;
  }
  .Three{
    grid-column: 1 / 2;
    grid-row: 2 / 5;
  }
  .Four{
    grid-column: 3 / 4;
  }

  /* grid track */
.wrapper1, .wrapper2, .wrapper3, .wrapper4{
  grid-auto-rows: minmax(100px , auto);
}

.wrapper1 > div , .wrapper2>div{
  background-color: black;
  color: white;
}

/* Basic concepts of grid layout */
/* CSS grid layout introduces a two-dimensional grid system to CSS. 
The features shown in this overview will then be explained in greater detail in the rest of this guide.

What is a grid?
A grid is a set of intersecting horizontal and vertical lines defining columns and rows.

CSS grid layout has the following features:

1. Fixed and flexible track sizes:  You can create a grid with fixed track sizes – using pixels for example. You can also create a grid using flexible sizes with percentages or with the fr unit designed for this purpose.

2. Item placement:  You can place items into a precise location on the grid using line numbers, names or by targeting an area of the grid. 

3. Creation of additional tracks to hold content:  You can define an explicit grid with grid layout. The Grid Layout specification is flexible enough to add additional rows and columns when needed. 

4. Alignment control:  Grid contains alignment features so we can control how the items align once placed into a grid area, and how the entire grid is aligned.

5. Control of overlapping content:  More than one item can be placed into a grid cell or area and they can partially overlap each other. This layering may then be controlled with the z-index property. */

/* Grid container
We create a grid container by declaring display: grid or display: inline-grid on an element. As soon as we do this, all direct children of that element become grid items.

In this example, I have a containing div with a class of wrapper and, inside are five child elements.All the direct children are now grid items. 

  selector{
      dispaly: grid;
  } */


.wrapper1{
  display: grid;
  gap: 10px;
}

/* Grid tracks
We define rows and columns on our grid with the grid-template-rows and grid-template-columns properties. These define grid tracks. 
A grid track is the space between any two adjacent lines on the grid. 
the grid-template-columns and grid-template-rows properties or the shorthand grid or grid-template properties. */
/* I can add to our earlier example by adding the grid-template-columns property, then defining the size of the column tracks.
I have now created a grid with three 200-pixel-wide column tracks.  */

.wrapper1{
  grid-template-columns: 200px 200px 200px;
}

/*The fr unit  
The new fr unit represents a fraction of the available space in the grid container. The next grid definition would create three equal width tracks that grow and shrink according to the available space.
*/

.wrapper1{
  grid-template-columns: 1fr 1fr 1fr;
}

/* Unequal sizes 
In this next example, we create a definition with a 2fr track then two 1fr tracks. The available space is split into four. Two parts are given to the first track and one part each to the next two tracks.
*/

.wrapper1{
  grid-template-columns: 1fr 2fr 1fr;
}


/* Mixing flexible and absolute sizes
The first track is 500 pixels, so the fixed width is taken away from the available space. The remaining space is divided into three and assigned in proportion to the two flexible tracks. */

.wrapper1{
    grid-template-columns: 800px 1fr 1fr;
}

/* Track listings with repeat() notation
Large grids with many tracks can use the repeat() notation, to repeat all or a section of the track listing. For example the grid definition:
  grid-templete-column:1fr 1fr 1fr; replaced (Can also be written as) grid-templete-column: repeat(3, 1fr); */


  .wrapper1{
    grid-template-columns: repeat(3, 1fr);
  }


/* In this next example I have created a grid with an initial 20-pixel track, then a repeating section of 6 1fr tracks then a final 20-pixel track.

.wrapper1{
  grid-template-columns: 20px repeat(6,1fr) 20px;
} */


/* In this next example, my grid will consist of 10 tracks, a 1fr track, and then followed by a 2fr track. This pattern will be repeated five times. */


.wrapper1{
  grid-template-columns: repeat(5, 1fr 2fr);
}


/* Implicit and explicit grids
If you place something outside of the defined grid—or due to the amount of content, more grid tracks are needed—then the grid creates rows and columns in the implicit grid. These tracks will be auto-sized by default, resulting in their size being based on the content that is inside them.

You can also define a set size for tracks created in the implicit grid with the grid-auto-rows and grid-auto-columns properties. */

/* In the below example, we use grid-auto-rows to ensure that tracks created in the implicit grid are 200 pixels tall. */

.wrapper1{
  grid-auto-rows: 200px;
}


/* Track sizing and minmax
For example, I may want my rows to never collapse smaller than 100 pixels, but if my content stretches to 300 pixels in height, then I would like the row to stretch to that height.
Grid has a solution for this with the minmax() function. */
/* In this next example I am using minmax() in the value of grid-auto-rows. */

.wrapper1{
  grid-auto-rows: minmax(200px, auto);
}

/* Grid lines
/* Grid then gives us numbered lines to use when positioning items. In our three column, two row grid we have four column lines.
Lines are numbered according to the writing mode of the document. In a left-to-right language, line 1 is on the left-hand side of the grid. (image show in thml line*/
/* Positioning items against lines
In the following example I am placing the first two items on our three column track grid, using the grid-column-start, grid-column-end, grid-row-start and grid-row-end properties.  */

/* example
the first item is placed against column line 1, and spans to column line 4, which in our case is the far-right line on the grid. It begins at row line 1 and ends at row line 3, therefore spanning two row tracks.

The second item starts on grid column line 1, and spans one track. This is the default so I do not need to specify the end line. It also spans two row tracks from row line 3 to row line 5.  */

.wrapper1{
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: 150px;

  max-width: 700px;
  margin: 0 auto;
}

.one-1{
  grid-column-start: 1;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
}

.Two-1{
  grid-column-start: 1;
  grid-row-start: 3;
  grid-row-end: 5;
}


/* Line-positioning shorthands
one line for columns with grid-column, and one line for rows with grid-row.
The value before the forward slash character (/) is the start line, the value after the end line. */

.one-1{
  grid-column: 1 / 4;
  grid-row: 1 / 3;
}

.Two-1{
  grid-column: 1;
  grid-row: 3 / 5;
}

.Five-1{
  grid-column: 2 / 4;
}

/* Grid cell:  A grid cell is the smallest unit on a grid. */

/*Grid areas:  Items can span one or more cells both by row or by column, and this creates a grid area. Grid areas must be rectangular. */

/* Gutters: Gutters or alleys between grid cells can be created using the column-gap and row-gap properties, or the shorthand gap. */
/* In the below example, I am creating a 10-pixel gap between columns and a 1em gap between rows.  */

.wrapper1{
  column-gap: 10px;
  row-gap: 2em;
}


/*Nesting grids  */

.one-1>div{
  margin: 20px;
   border: 2px solid #ffec99;
  border-radius: 5px;
  background-color: #fff9db;
  padding: 1em;
  color: black;
}

.one-1{
  display: grid;
  grid-template-columns: repeat(3 , 1fr);
}


/* Relationship of grid layout to other layout methods */

/* Grid and flexbox
Grid was designed for two-dimensional layout - rows, and columns at the same time
You have already learned how to use flexbox, the similarities should help you get to grips with Grid. */

/* 
One-dimensional versus two-dimensional layout

A simple example can demonstrate the difference between one- and two-dimensional layouts.
In this first example, I am using flexbox to lay out a set of boxes. I have five child items in my container, and I have given the flex properties values so that they can grow and shrink from a flex-basis of 150 pixels. I have also set the flex-wrap property to wrap
 */


.flexbox{
  margin-top: 10px;
  width: 600px;
  border: 1px solid black;
  padding: 10px;

  display: flex;
  flex-wrap: wrap;
}

.flexbox>div{
  flex: 1 1 150px;
  height: 50px;
  margin: 10px;
  background-color: blue;
  color: white;
}

/* In the image, you can see that two items have wrapped onto a new line. These items are sharing the available space and not lining up underneath the items above. This is because when you wrap flex items, each new row (or column when working by column) is an independent flex line in the flex container. Space distribution happens across the flex line. */

/* A common question then is how to make those items line up. This is where you want a two-dimensional layout method: You want to control the alignment by row and column, and this is where grid comes in. */

/* 
The same layout with CSS grids

In this next example, I create the same layout using Grid. This time we have three 1fr column tracks. We do not need to set anything on the items themselves; they will lay themselves out one into each cell of the created grid. As you can see they stay in a strict grid, lining up in rows and columns. With five items, we get a gap on the end of row two. */

.wrapper2{
  margin: 10px auto;
  max-width: 600px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}

/* A simple question to ask yourself when deciding between grid or flexbox is:

do I only need to control the layout by row or column – use a flexbox
do I need to control the layout by row and column – use a grid */


/* flexbox =>  they will work out their spacing based on their size and the available space on that line.
grid =>  You allow the auto-placement rules to place the items into the grid cells according to that strict grid. It is possible to create tracks that respond to the size of the content, however, they will also change the entire track. */

/* Box alignment */

/* which uses flexbox aleady done */
/* I have a container with three items inside. The wrapper min-height is set, so it defines the height of the flex container. I have set align-items on the flex container to flex-end so the items will line up at the end of the flex container. I have also set the align-self property on box1 so it will override the default and stretch to the height of the container and on box2 so it aligns to the start of the flex container. 
      .wrapper {
           display: flex;
          align-items: flex-end;
          min-height: 200px;
        }
      .box1 {
        align-self: stretch;
        }
        .box2 {
        align-self: flex-start;
        }

*/

/* Alignment in CSS Grids
This example uses a grid to create the same layout. This time we are using the box alignment properties as they apply to a grid layout. So we align to start and end rather than flex-start and flex-end. In the case of a grid layout, we are aligning the items inside their grid area. In this case that is a single grid cell, but it could be an area made up of several grid cells. 

          .wrapper {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            align-items: end;
            grid-auto-rows: 200px;
          }
          .box1 {
            align-self: stretch;
          }
          .box2 {
            align-self: start;
          }
*/

/* The fr unit and flex-basis
The fr unit works to assign a proportion of available space in the grid container to our grid tracks. The fr unit, when combined with the minmax() function can give us very similar behavior to the flex properties in flexbox while still enabling the creation of a layout in two dimensions. */


/* Auto-filling grid tracks */
/* We can use grid to create a similar effect to flexbox, while still keeping the content arranged in strict rows and columns, by creating our track listing using repeat notation and the auto-fill and auto-fit properties. */

/* In this next example, I have used the auto-fill keyword in place of an integer in the repeat notation and set the track listing to 200 pixels.

This means that grid will create as many 200 pixels column tracks as will fit in the container. */

.wrapper3>div{
  background-color: red;
}


.wrapper3{
  padding: 10px;
  border: 2px solid black;
  
  margin-top: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px,1fr));
  gap: 10px;
}


/* A flexible number of tracks */
/* This isn't quite the same as flexbox. 

 In the flexbox example, the items are larger than the 200 pixel basis before wrapping. We can achieve the same in grid by combining auto-fit and the minmax() function. 

In this next example, I create auto filled tracks with minmax. I want my tracks to be a minimum of 200 pixels, so I set the maximum to be 1fr. */

.wrapper4>div{
  background-color: red;
}


.wrapper4{
  padding: 10px;
  border: 2px solid black;
  
  margin-top: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px,1fr));
  gap: 10px;
}

/* Grid and absolutely positioned elements and absolutely positioned elements*/
/* Grid interacts with absolutely positioned elements, which can be useful if you want to position an item inside a grid or grid area.  */


/* A grid container as containing block */
/* To make the grid container a containing block you need to add the position property to the container with a value of relative, just as you would make a containing block for any other absolutely positioned items.

In the below example I have a wrapper containing four child items. Item three is absolutely positioned and also placed on the grid using line-based placement. The grid container has position: relative and so becomes the positioning context of this item. */

.wrapper5{
  margin-top: 30px;
  display: grid;
  grid-template-columns: repeat(4,1fr);
  grid-auto-rows: 200px;
  gap: 10px;

  border: 2px solid black;
  position: relative;
}

.wrapper5>div{
  background-color: hotpink;
  border: 2px solid #dd0e72;
  padding: 20px;
  color: red;
}

.wrapper5 div:nth-child(3){
  grid-column: 2/5;
  grid-row: 1/3;

  position: absolute;
  top: 40px;
  left: 40px;
}

/* Using display: contents
If I now add display: contents to the rules for box1, the box for that item vanishes and the sub-items now become grid items and lay themselves out using the auto-placement rule */

.wrapper6 {
  margin-top: 25px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
  gap: 20px;

  border: 2px solid yellowgreen;
  padding: 10px;
  background-color: whitesmoke;
}
.wrapper6>div{
  background-color: green;
}
.wrapper6 .box1 {
  grid-column-start: 1;
  grid-column-end: 4;
  display: contents;
}
.wrapper6 .box1 .nested{
  background-color: red;
  margin: 10px;
}

/* Grid layout using line-based placement */
/* The lines are numbered for columns and rows, and are indexed from 1. Note that grid is indexed according to the writing mode of the document. In a left to right language such as English line 1 is on the left-hand side of the grid. */

/* A basic example */
/* As a very simple example we can take a grid with 3 column tracks and 3 row tracks. This gives us 4 lines in each dimension. */

.wrapper7 > div{
  /* background-color: #be3979; */
  border-left: 3px dotted black;
  border-bottom: 3px dotted black;
}

.box{
  padding: 30px;
  border: 1px solid black;
  margin: 20px;
  position: relative;
}

.wrapper7{
  max-width: 700px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(3, minmax(20px , 1fr));
  grid-template-rows: repeat(3, minmax(100px, 120px));
  gap: 1.5px;
}

span:nth-child(2)::before{
  content: "1";
  position: absolute;
  top: 7px;
  left: 465px;
  font-size: 30px;
}
span:nth-child(3)::before{
  content: "2";
  position: absolute;
  top: 7px;
  left: 695px;
  font-size: 30px;
}
span:nth-child(4)::before{
  content: "3";
  position: absolute;
  top: 7px;
  left: 924px;
  font-size: 30px;
}
span:nth-child(5)::before{
  content: "4";
  position: absolute;
  top: 7px;
  left: 1156px;
  font-size: 30px;
}
span:nth-child(6)::before{
  content: "1";
  position: absolute;
  top: 25px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(7)::before{
  content: "2";
  position: absolute;
  top: 137px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(8)::before{
  content: "3";
  position: absolute;
  top: 262px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(9)::before{
  content: "4";
  position: absolute;
  top: 384px;
  left: 443px;
  font-size: 30px;
}

/* Positioning items by line number */
/* We can use line-based placement to control where these items sit on the grid. We would like the first item to start on the far left of the grid and span a single column track.  */
.wrapper8 > div{
  /* background-color: #be3979; */
}

.wrapper8{
  max-width: 1100px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(3, minmax(20px , 1fr));
  grid-template-rows: repeat(3, minmax(100px, 130px));
  border: 2px solid black;
}

.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: 1;
  grid-column-end: 2;
  grid-row-start: 1;
  grid-row-end: 4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: 2;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 2;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: 3;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 3;
  grid-row-end: 4;
}

/* The grid-column and grid-row shorthands */
/* We have quite a lot of code here to position each item. It should come as no surprise to know there is a shorthand. The grid-column-start and grid-column-end properties can be combined into grid-column, grid-row-start and grid-row-end into grid-row. */
.wrapper8 div:nth-child(1){
  grid-column: 1 / 2;
  grid-row: 1 / 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2 / 3;
  grid-row: 1 / 2;
}
.wrapper8 div:nth-child(3){
  grid-column: 3 / 4;
  grid-row: 1 / 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / 4;
  grid-row: 3 / 4;
}

/* Default spans */
/* we specified every end row and column line, in order to demonstrate the properties, however in practice if an item only spans one track you can omit the grid-column-end or grid-row-end value. Grid defaults to spanning one track. */

/* Default spans with longhand placement */
.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: 1;
  grid-row-start: 1;
  grid-row-end: 4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: 2;
  grid-row-start: 1;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: 3;
  grid-row-start: 1;
  grid-row-end: 3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 3;
}

/* Default spans with shorthand placement */
.wrapper8 div:nth-child(1){
  grid-column: 1 ;
  grid-row: 1 / 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2;
  grid-row: 1 / 2;
}
.wrapper8 div:nth-child(3){
  grid-column: 3;
  grid-row: 1 / 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / 4;
  grid-row: 3;
} 

/* The grid-area property
We can take things a step further and define each area with a single property – grid-area. The order of the values for grid-area are as follows.

grid-row-start
grid-column-start
grid-row-end
grid-column-end */

.wrapper8 div:nth-child(1){
  grid-area: 1 /1 /4 /2;
}

.wrapper8 div:nth-child(2){
  grid-area: 1 /2 / 2 / 3;
}
.wrapper8 div:nth-child(3){
  grid-area: 1 / 3 / 3 / 4;
}
.wrapper8 div:nth-child(4){
  grid-area: 3 / 2 / 4 / 4;
} 

/* We will explore how grids work with writing modes in a later article however we have the concept of four flow-relative directions:

block-start
block-end
inline-start
inline-end */


/* Counting backwards
We can also count backwards from the block and inline end of the grid, for English that would be the right-hand column line and final row line. These lines can be addressed as -1, and you can count back from there – so the second last line is -2. It is worth noting that the final line is the final line of the explicit grid, the grid defined by grid-template-columns and grid-template-rows, and does not take into account any rows or columns added in the implicit grid outside of that. */

.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: -1;
  grid-column-end: -2;
  grid-row-start: -1;
  grid-row-end: -4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: -2;
  grid-column-end: -3;
  grid-row-start: -1;
  grid-row-end: -2;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: -3;
  grid-column-end: -4;
  grid-row-start: -1;
  grid-row-end: -3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: -2;
  grid-column-end: -4;
  grid-row-start: -3;
  grid-row-end: -4;
}

/* Using the span keyword
In addition to specifying the start and end lines by number, you can specify a start line and then the number of tracks you would like the area to span. */
.wrapper8 div:nth-child(1){
  grid-column: 1 ;
  grid-row: 1 / span 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2;
  grid-row: 1 ;
}
.wrapper8 div:nth-child(3){
  grid-column: 3;
  grid-row: 1 / span 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / span 4;
  grid-row: 3;
} 

/* You can also use the span keyword in the value of grid-row-start/grid-row-end and grid-column-start/grid-column-end. The following two examples will create the same grid area. In the first we set the start row line, then the end line we explain that we want to span 3 lines. The area will start at line 1 and span 3 lines to line 4.

.box1 {
  grid-column-start: 1;
  grid-row-start: 1;
  grid-row-end: span 3;
}


In the second example, we specify the end row line we want the item to finish at and then set the start line as span 3. This means the item will need to span upwards from the specified row line. The area will start at line 4 and span 3 lines to line 1.

.box1 {
  grid-column-start: 1;
  grid-row-start: span 3;
  grid-row-end: 4;
} */



/* Layout using named grid lines */
/* Naming lines when defining a grid */

/* You can assign some or all of the lines in your grid a name when you define your grid with the grid-template-rows and grid-template-columns properties. This time I'll create the grid using named lines. */


.item{
  color: rgb(31, 28, 28);
  font-size: 25px;
  
  display: flex;
  align-items: center;
  justify-content: center;
}

.container{
  margin: 0 auto;
  max-width: 900px;
  display: grid;

  /* Giving lines multiple names */
  /* You may want to give a line more than one name, perhaps it denotes the sidebar-end and the main-start for example. To do this add the names inside the square brackets with whitespace between them [sidebar-end main-start]. You can then refer to that line by either of the names. */

  /* grid-template-columns: repeat(3,1fr); */
  grid-template-columns: [one-start] 1fr [one-end two-start] 1fr [two-end three-start] 1fr [three-end four-start] 1fr [four-end];
  /* grid-template-rows:  120px 80px  100px 200px 110px 120px; */
  grid-template-rows: [header-start] 100px [header-end menu-start]  60px [menu-end box-start]  100px [box-end content-start]  200px [content-end footer-start] 130px [footer-end];
  gap: 10px;
}

.header1{
  background-color: red;
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: header-start;
  grid-row-end: header-end;
}
.menu1{
  background-color: greenyellow;
  /* grid-area: 2 / 1 / 3 / 4; */
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: menu-start;
  grid-row-end: menu-end;
}
.box1{
  background-color: rgb(40, 40, 153);
  /* grid-area: 3 / 1 / 4 / 2; */
  grid-column-start: one-start;
  grid-column-end: one-end;
  grid-row-start: box-start;
  grid-row-end: box-end;
}
.box2{
  background-color: rgb(187, 69, 89);
  /* grid-area: 3 / 2 / 4 / 3; */
  grid-column-start: two-start;
  grid-column-end: two-end;
  grid-row-start: box-start;
  grid-row-end: box-end;
}
.sidebar1{
  background-color: darkblue;
  /* grid-area: 3 / 3 / 6 / 4; */
  grid-column-start: three-start;
  grid-column-end: four-end;
  grid-row-start: box-start;
  grid-row-end: content-end;
}
.content1{
  background-color: rgb(20, 187, 216);
  /* grid-area: 4 / 1 / 6 / 3; */
  grid-column-start: one-start;
  grid-column-end: two-end;
  grid-row-start: content-start;
  grid-row-end: content-end;
}
.footer1{
  background-color: gray;
  /* grid-area: 6 / 1 / 7 / 4; */
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: footer-start;
  grid-row-end: footer-end;
}


/* Implicit Grid lines from named areas */
/* If we take the layout created in the guide to Grid Template Areas, we can use the lines created by our areas to see how this works. */
/* In this example I have added an extra div with a class of overlay. We have named areas created using the grid-area property, then a layout created in grid-template-areas.  */

/* The area names are: 'hd' 'ft' 'main' 'sd'
This gives us column and row lines: 'hd-start' 'hd-end' 'ft-start' 'ft-end' 'main-start' 'main-end' 'sd-start' 'sd-end' */


.container1{
  margin: 10px auto;
  max-width: 900px;
  border: 2px solid black;
  display: grid;

  grid-template-columns: repeat(10 ,1fr);
  grid-template-rows: repeat(3, minmax(120px , auto));

  grid-template-areas: 
      'hd hd hd hd hd hd hd hd hd hd'
      'ft ft ft ft main main main main main main'    
      'sd sd sd sd sd sd sd sd sd sd'
  ;
}

.container1 > .item{
  background-color: #dd0e72;
}
.container1 .overlay{
  z-index: 10;
  grid-column: ft-start / ft-end;
  grid-row: ft-start / sd-end;
  border: 4px solid rgb(92, 148, 13);
  background-color: rgba(92, 148, 13, 0.4);
  color: red;
  font-size: 150%;

  display: flex;
  justify-content: center;
}
.header2{
  grid-area: hd;
  border-bottom: 2px solid white;
}
.sidebar2{
  grid-area: ft;
  border-bottom: 2px solid white;
  border-right: 2px solid white;
}
.content2{
  grid-area: main;
  border-bottom: 2px solid white;
}
.footer2{
  grid-area: sd;
}


/* Multiple lines with the same name with repeat() */

/* Twelve-column grid using repeat() */
/* I am creating a grid with twelve equal width columns. Before defining the 1fr size of the column track I am also defining a line name of [col-start]. This means that we will end up with a grid that has 12 column lines all named col-start before a 1fr width column. */


.wrapper10 > .item{
  background-color: #fff9db;
}

.wrapper10{
  margin: 10px auto;
  border: 2px solid black;

  display: grid;
  grid-template-columns: repeat(12, [col-start] 1fr);
}

/* To place our item from the first line named col-start to the 5th */
.box3{
  grid-column: col-start / col-start 5;
}

/* You can also use the span keyword here. My next item will be placed from the 7th line named col-start and span 3 lines. */
.box4{
  grid-column: col-start 7 / span 3;
}


/* Defining named lines with a track list */

/* The code below would create an eight track grid, with a narrower 1fr width column named col1-start followed by a wider 3fr column named col2-start. */

/* .selector{
  grid-template-columns: repeat(4, [col1-start] 1fr [col2-start] 3fr);
} */

/* If your repeating syntax puts two lines next to each other then they will be merged, and create the same result as giving a line multiple names in a non-repeating track definition. The following definition, creates four 1fr tracks, which each have a start and end line. */

/* .selector{
  grid-template-columns: repeat(4, [col-start] 1fr [col-start]);
} */

/* If we write this definition out without using repeat notation it would look like this. */
/* .selector{
  grid-template-columns: [col-start] 1fr [col-end col-start] 1fr [col-end col-start] 1fr [col-end col-start] 1fr [col-end];
} */


/* Grid template areas */
/* This method involves placing our items using named template areas, and we will find out exactly how this method works. You will see very quickly why we sometimes call this the ascii-art method of grid layout! */

/* Naming a grid area */
/* You have already encountered the grid-area property. This is the property that can take as a value all four of the lines used to position a grid area. */

/* selector{
  grid-area: 1 / 1 / 4 / 2;
} */

/* We can also define an area by giving it a name and then specify the location of that area in the value of the grid-template-areas property. You can choose what you would like to name your area. For example, if I wish to create the layout shown below I can identify four main areas.

a header
a footer
a sidebar
the main content */

/* With the grid-area property I can assign each of these areas a name. */

.wrapper9 > div{
  background-color: #ffec99;
}

.wrapper9{
  display: grid;
  grid-template-columns: repeat(9, 1fr);
  grid-template-rows: repeat(3,200px);
  gap: 5px;
  max-width: 900px;
 margin: 0 auto;
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    "ft ft ft ft ft ft ft ft ft"
  ;

}
.header{
  grid-area: hd;
}
.sidebar{
  grid-area: sd;
}
.content{
  grid-area: ct;
}
.footer{
  grid-area: ft;
}

/* Leaving a grid cell empty */
/* To leave a cell empty use the full stop character, '.'. */
.wrapper9{
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    ". . . ft ft ft ft ft ft"
    ;
}

/* Spanning multiple cells */
/* The area that you create by chaining the area names must be rectangular, at this point there is no way to create an L-shaped area. The specification does note that a future level might provide this functionality. You can however span rows just as easily as columns. For example we could make our sidebar span down to the end of the footer by replacing the . with sd. */

.wrapper9{
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    "sd sd sd ft ft ft ft ft ft"
    ;  
}


/* Redefining the grid using media queries */
/* the names for your areas outside of any media queries. That way the content area would always be called main no matter where on the grid it is placed. */

.wrapper9{
  grid-template-areas: 
    "hd"
    "sd" 
    "ct"
    "ft"
    ;  
}

/* media queries */
@media (min-width: 500px) {
  .wrapper9 {
    grid-template-columns: repeat(9, 1fr);
    grid-template-areas:
      "hd hd hd hd   hd   hd   hd   hd   hd"
      "sd sd sd ct ct ct ct ct ct"
      "sd sd sd  ft  ft   ft   ft   ft   ft";
  }
}
@media (min-width: 700px) {
  .wrapper9 {
    grid-template-areas:
      "hd hd hd   hd   hd   hd   hd   hd hd"
      "sd sd ct ct ct ct ct ft ft";
  }
}



/* Items with placement properties */
/* In the example below I have 12 grid items. Item 2 and item 5 have been placed using line based placement on the grid. You can see how those items are placed and the other items then auto-place in the spaces. */

.wrapper11{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-auto-rows: 200px;
  gap: 5px;

  border: 3px solid black;
  margin: 10px auto;
  max-width: 1300px;
  padding: 10px;
}

.wrapper11 > .placement{
  background-color: #fff9db;
  border: 2px solid #a18e2b;
  font-size: 25px;

  display: flex;
  justify-content: center;
  align-items: center;
}

.wrapper11 div:nth-child(2){
  grid-column: 3;
  grid-row: 2 / 4;
}

.wrapper11 div:nth-child(5){
  grid-column: 1 / 3;
  grid-row: 1 / 3;
}

/* Deal with items that span tracks */
/* In this next example I have added to the layout by setting odd items to span two tracks both for rows and columns. I do this with the grid-column-end and grid-row-end properties and setting the value of this to span 2. */

/* You can see how this then leaves gaps in the grid, as for the auto-placed items if grid comes across an item that doesn't fit into a track, it will move to the next row until it finds a space the item can fit in. */

.wrapper11 div:nth-child(4n+1){
  grid-column-end: span 2;
  grid-row-end: span 2;
}


/* Filling in the gaps */
/* To do this, add the property grid-auto-flow with a value of dense to the container. This is the same property you use to change the flow order to column, so if you were working in columns you would add both values grid-auto-flow: column dense. */

.wrapper11{
  grid-auto-flow: dense;
}



/* Box alignment in grid layout */
/* The same standard flexbox uses for aligning items in its flex container.  */

/* Aligning items on the Block Axis */
/* The align-self and align-items properties control alignment on the block axis. */

.wrapper13{
  margin: 20px auto;
  max-width: 900px;
  border: 2px solid green;
  padding: 25px;

  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-auto-rows: 100px;
  gap: 10px;
  grid-template-areas: 
  'a a a a b b b b'
  'a a a a b b b b'
  'c c c c d d d d'
  'c c c c d d d d'
  ;

/* Using align-items
In the following example, I have four grid areas within my grid. I can use the align-items property on the grid container, to align the items using one of the following values:
auto | normal | start | end | center | stretch | baseline | first baseline | last baseline */

/* The align-items property sets the align-self property for all of the child grid items. This means that you can set the property individually, by using align-self on a grid item. */  

  /* align-items: start; */
  /* align-items: end; */
  /* align-items: center; */
  /* align-items: stretch; */
  /* align-items: baseline; */
  /* align-items: first baseline; */
  /* align-items: last baseline; */



}

.wrapper13 > .box-alignment{
  background-color: #ffec99;
  padding: 20px;
  font-size: 23px;
  font-weight: 800;
}

.wrapper13  .item1{
  grid-area: a;
}

.wrapper13 > .item2{
  grid-area: b;

  /* Using align-self */
  /* I am using the align-self property, to demonstrate the different alignment values. The first area, is showing the default behavior of align-self, which is to stretch. The second item, has an align-self value of start, the third end and the fourth center. */

  /* align-self: start; */

  /* Justifying Items on the Inline Axis */
  /* As align-items and align-self deal with the alignment of items on the block axis, justify-items and justify-self do the same job on the inline axis. The values you can choose from are the same as for align-self.
  auto | normal | start | end | center | stretch | baseline | first baseline | last baseline */

  /* The justify-self and justify-items properties are not implemented in flexbox. This is due to the one-dimensional nature of flexbox, and that there may be multiple items along the axis, making it impossible to justify a single item. To align items along the main, inline axis in flexbox you use the justify-content property. */

  /* Shorthand properties
The place-items property is shorthand for align-items and justify-items.

The place-self property is shorthand for align-self and justify-self. */

  justify-self: start;
}

.wrapper13 > .item3{
  grid-area: c;
  /* align-self: end; */
  justify-self: end;
}

.wrapper13 > .item4{
  grid-area: d;
  /* align-self: center; */
  justify-self: center;
}


/* Center an item in the area
By combining the align and justify properties we can easily center an item inside a grid area. */

.center{
  margin: 10px auto;
  max-width: 900px;
  border: 2px solid green;

  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-auto-rows: 200px;
  grid-template-areas: 
  '. a a .'
  '. a a .'
  ;
}

.center > .box-alignment{
  background-color: rgb(46, 110, 167);
  padding: 30px;
  color: white;
  font-size: 25px;
  border-radius: 5px;
  grid-area: a;
  justify-self: center;
  align-self: center;
}




.wrapper14{
  margin: 10px auto;
  border: 2px solid rgb(170, 115, 48);
  background-color: rgb(245, 234, 221);
  width: 500px;
  height: 500px;
  padding: 20px;
  /* writing-mode: vertical-lr; */

  display: grid;
  grid-template-columns: repeat(3, 100px);
  grid-template-rows: repeat(3, 100px);
  gap: 5px;

  grid-template-areas:
  'a a b'
  'a a b'
  'c d d'
  ;

  /* Aligning the grid tracks on the block axis */
/* this operates on the block and inline axes, with align-content aligning tracks on the block axis, and justify-content performing alignment on the inline axis. The place-content property is shorthand for align-content and justify-content. The values for align-content, justify-content and place-content are: */
/* normal | start | end |center | stretch | space-around | space-between | space-evenly | baseline | first baseline | last baseline */

/* In the below example I have a grid container of 500 pixels by 500 pixels. I have defined 3 row and column tracks each of 100 pixels with a 10 pixel gutter. */

  /* align-content: start; */
  /* align-content: end; */
  /* align-content: center; */
  /* align-content: stretch; */
  /* align-content: space-around; */
  /* align-content: space-between; */
  /* align-content: space-evenly; */
  /* align-content: baseline; */
  /* align-content: first baseline; */
  /* align-content: last baseline; */

  /* Justifying the grid tracks on the inline axis */
/* On the inline axis, we can use justify-content to perform the same type of alignment that we used align-content for in the block axis. */

  justify-content: space-evenly;
}

.wrapper14 > .placement{
  background-color: #a18e2b;  
  border-radius: 5px;
  color: white;
  font-size: 23px;

  display: flex;
  justify-content: center;
  align-items: center;
}

.wrapper14 > .item1{
  grid-area: a;

  /* Alignment and auto margins */
  /* Another way to align items inside their area is to use auto margins. If you have ever centered your layout in the viewport, by setting the right and left margin of the container block to auto, you know that an auto margin absorbs all of the available space. */

  margin-left: auto;
  padding: 15px;
}
.wrapper14 > .item2{
  grid-area: b;
}
.wrapper14 > .item3{
  grid-area: c;
}
.wrapper14 > .item4{
  grid-area: d;
}

/* subgrid */
/* Introduction to subgrid */
/* When you add display: grid to a grid container, only the direct children become grid items and can then be placed on the grid you created. The children of these items display in normal flow. */
/* You can "nest" grids by making a grid item a grid container. */

/* For example, if you use grid-template-columns: subgrid and the nested grid spans three column tracks of the parent, the nested grid will have three column tracks of the same size as the parent grid.  */

/* Subgrid for columns */

/* I have a grid layout with nine 1fr column tracks and four rows that are a minimum of 100px tall. */
/* I place .item from column lines 2 to 7 and rows 2 to 4. I then make this grid item into a grid, giving it column tracks that are a subgrid and defining rows as normal. */

/* .grid{
  max-width: 900px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(9 , 1fr);
  grid-template-rows: repeat(6,minmax(100px , 1fr));

  background-color: #faf5de;
  border: 2px solid forestgreen;
  border-radius: 5px;
}

.grid > .item1{
  grid-column: 2 / 8;
  grid-row: 2 / 6;
  background-color: #ffec99;

  display: grid;
  grid-template-columns: subgrid;
  grid-template-rows: repeat(3,80px);
}

.subitem{
  background-color: #a18e2b;

  grid-column: 4 / 8;
  grid-row: 1 / 6;
} */

/* Subgrid for rows */
/* we are using subgrid as the value of grid-template-rows and defining explicit column tracks. */

/* .grid{
  max-width: 900px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(9 , 1fr);
  grid-template-rows: repeat(6,minmax(100px , 1fr));

  background-color: #faf5de;
  border: 2px solid forestgreen;
  border-radius: 5px;
}

.grid > .item1{
  grid-column: 2 / 8;
  grid-row: 2 / 6;
  background-color: #ffec99;

  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: subgrid;
}

.subitem{
  background-color: #a18e2b;

  grid-column: 4 / 8;
  grid-row: 1 / 6;
} */

/* A subgrid in both dimensions */
/* You can define both rows and columns as a subgrid */

.grid{
  max-width: 900px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(9 , 1fr);
  grid-template-rows: repeat(6,minmax(100px , 1fr));

  background-color: #faf5de;
  border: 2px solid forestgreen;
  border-radius: 5px;
}

.grid > .item1{
  grid-column: 2 / 8;
  grid-row: 2 / 6;
  background-color: #ffec99;

  display: grid;
  grid-template-columns: subgrid;
  grid-template-rows: subgrid;

  /* The gap properties and subgrid */
  /* If you have a gap, column-gap, or row-gap specified on the parent
  You can see this in the example below. The parent grid has a gap of 20px for rows and columns. The subgrid has row-gap set to 0. */

  gap: 5px;

}

.subitem{
  background-color: #a18e2b;

  grid-column: 7 / 8;
  grid-row: 1 / 6;
}

/* The gap properties and subgrid */
.subitem2{
  background-color: red;
  grid-column: 6 ;
  grid-row: 1 / 5;
}
.subitem3{
  background-color: rgb(30, 209, 14);
  grid-column: 5 ;
  grid-row: 1 / 4;
}
.subitem4{
  background-color: rgb(236, 34, 84);
  grid-column: 4 ;
  grid-row: 1 / 3;
}
.subitem5{
  background-color: rgb(0, 255, 242);
  grid-column: 1 / 4 ;
  grid-row: 1 / 2;
}



/* No implicit grid in a subgridded dimension */
/* Take a look at the next example — it uses the same parent and child grid as in the example above. However, I have twelve items inside the subgrid trying to autoplace into ten grid cells. As the subgrid is on both dimensions, there is nowhere for the extra two items to go, so they go into the last track of the grid, as defined in the specification. */
.grid1{
  max-width: 900px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(9 , 1fr);
  grid-template-rows: repeat(9,minmax(100px , 1fr));

  background-color: #faf5de;
  border: 2px solid forestgreen;
  border-radius: 5px;
}

.grid1 > .item2{
  grid-column: 2 / 8;
  grid-row: 2 / 8;
  background-color: #ffec99;

  display: grid;
  grid-template-columns: subgrid;
  grid-template-rows: subgrid;
}

.subitem1{
  background-color: #a18e2b;
  border-radius: 10px;

}

  /* grid all 
____________properties________

grid-template-columns: The grid-template-columns CSS property defines the line names and track sizing functions of the grid columns.

Syntax: 
grid-template-column: 
                    auto
                    none
                    100px 1fr
                    [linename] 100px
                    [linename1] 100px [linename2] [linename3]
                    minmax(100px , 1fr)
                    fit-content(40%)
                    repeat(3,200px)
                    subgrid
                    masonry
                    repeat(auto-fill, minmax(200px, 1fr))
                    repeat(auto-fit , minmax(200px, 1fr))
                    200px repeat(auto-fill , 200px) 300px;


grid-template-rows: The grid-template-rows CSS property defines the line names and track sizing functions of the grid rows.

Syntax: 
grid-template-row:
                    auto
                    none
                    100px 1fr
                    [linename] 100px
                    [linename1] 100px [linename2] [linename3]
                    minmax(100px , 1fr)
                    fit-content(40%)
                    repeat(3,200px)
                    subgrid
                    masonry
                    repeat(auto-fill, minmax(200px, 1fr))
                    repeat(auto-fit , minmax(200px, 1fr))
                    200px repeat(auto-fill , 200px) 300px;


grid-template-areas: The grid-template-areas CSS property specifies named grid areas, establishing the cells in the grid and assigning them names.
! Those areas are not associated with any particular grid item, but can be referenced from the grid-placement properties grid-row-start, grid-row-end, grid-column-start, grid-column-end, and their shorthands grid-row, grid-column, and grid-area.



Syntax:
grid-template-area:
                    none
                    "a b"
                    "
                    'a b b'
                    'a c d
                    "


! grid-template: The grid-template CSS property is a shorthand property for defining grid columns, grid rows, and grid areas.

Constituent properties
This property is a shorthand for the following CSS properties:

grid-template-areas
grid-template-columns
grid-template-rows


Syntax:
grid-template:
                    none
                    _______grid-template-rows / grid-template-columns values_______
                    100px 1fr / 50px 1fr
                    auto 1fr / auto 1fr auto
                    [linename] 100px / [linename1] 40% [linename2]
                    fit-content(100px) / fit-content(40%)
                    ______grid-template-areas grid-template-rows / grid-template-column values_______
                    "
                    'a a a'
                    'b b b'
                    "
                    "
                    'a a a' 20%
                    'b b b' auto
                    "
                    ![header-top] "a a a" [header-bottom]
                     ! [main-top] "b b b" 1fr [main-bottom] / auto 1fr auto


grid-auto-columns: The grid-auto-columns CSS property specifies the size of an implicitly-created grid column track or pattern of tracks.

Syntax:
grid-auto-columns:
                    auto
                    min-content
                    max-content
                    100px
                    minmax(200px,1fr)
                    minmax(100px, auto) minmax(max-content, 2fr) minmax(20%, 80vmax)
                    100px 300px 200px


grid-auto-rows: The grid-auto-flow CSS property controls how the auto-placement algorithm works, specifying exactly how auto-placed items get flowed into the grid.

Syntax:
grid-auto-row:
                    auto
                    min-content
                    max-content
                    100px
                    minmax(200px,1fr)
                    minmax(100px, auto) minmax(max-content, 2fr) minmax(20%, 80vmax)
                    100px 300px 200px


grid-auto-flow: The grid-auto-flow CSS property controls how the auto-placement algorithm works, specifying exactly how auto-placed items get flowed into the grid.

Syntax:
grid-auto-flow:
                    row
                    column
                    dense
                    row dense
                    column dense

grid-row-start: The grid-row-start CSS property specifies a grid item's start position within the grid row by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the inline-start edge of its grid area.

Syntx:
grid-row-start:
                    auto
                    3
                    span 2


grid-column-start: The grid-column-start CSS property specifies a grid item's start position within the grid column by contributing a line, a span, or nothing (automatic) to its grid placement. This start position defines the block-start edge of the grid area.

Synatx:
grid-column-start:
                    auto
                    3
                    span 3


grid-row-end: The grid-row-end CSS property specifies a grid item's end position within the grid row by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the inline-end edge of its grid area.

Syntax:
grid-row-end:
                    auto
                    3
                    span 3


grid-column-end: The grid-column-end CSS property specifies a grid item's end position within the grid column by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the block-end edge of its grid area.

Syntax:
grid-column-end:
                    auto
                    3
                    span 3


grid-row: The grid-row CSS shorthand property specifies a grid item's size and location within a grid row by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the inline-start and inline-end edge of its grid area.

Constituent properties
This property is a shorthand for the following CSS properties:

grid-row-end
grid-row-start

Syntax:
grid-row: 
                    auto
                    auto / auto
                    5 / 7
                    span 5
                    span 3 / 7
                    2 / span 2


grid-column: The grid-column CSS shorthand property specifies a grid item's size and location within a grid column by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the inline-start and inline-end edge of its grid area.

Constituent properties
This property is a shorthand for the following CSS properties:

grid-column-end
grid-column-start


Syntax:
grid-column:
                    auto
                    auto / auto
                    5 / 7
                    span 5
                    span 3 / 7
                    2 / span 2


grid-area: The grid-area CSS shorthand property specifies a grid item's size and location within a grid by contributing a line, a span, or nothing (automatic) to its grid placement, thereby specifying the edges of its grid area.

Constituent properties
This property is a shorthand for the following CSS properties:

grid-row-start
grid-column-start
grid-row-end
grid-column-end

Syntax:
grid-area:
                      auto
                      auto / auto
                      auto / auto / auto
                      auto / auto / auto / auto
                      ! some-grid-area
                      ! some-grid-area / another-grid-area
                      span 3
                      ! span 3 / span some-grid-area
                      ! 2 span / another-grid-area span

______________function_________

repeat(): The repeat() CSS function represents a repeated fragment of the track list, allowing a large number of columns or rows that exhibit a recurring pattern to be written in a more compact form.


Syntx:
Repeat():
                       (4, 1fr)
                       (4, [col-start] 250px [col-end])
                       (4, [col-start] 60% [col-end])
                       (4, [col-start] 1fr [col-end])
                       (4, [col-start] min-content [col-end])
                       (4, [col-start] max-content [col-end])
                       (4, [col-start] auto [col-end])
                       (4, [col-start] minmax(100px, 1fr) [col-end])
                       (4, [col-start] fit-content(200px) [col-end])
                       (4, 10px [col-start] 30% [col-middle] auto [col-end])
                       (4, [col-start] min-content [col-middle] max-content [col-end])
                       (auto-fill, 250px)
                       (auto-fit, 250px)
                       (auto-fill, [col-start] 250px [col-end])
                       (auto-fit, [col-start] 250px [col-end])
                       (auto-fill, [col-start] minmax(100px, 1fr) [col-end])
                       (auto-fill, 10px [col-start] 30% [col-middle] 400px [col-end])
                       (4, 250px)
                       (4, [col-start] 250px [col-end])
                       (4, [col-start] 60% [col-end])
                       (4, [col-start] minmax(100px, 1fr) [col-end])
                       (4, [col-start] fit-content(200px) [col-end])
                       (4, 10px [col-start] 30% [col-middle] 400px [col-end])

minmax(): The minmax() CSS function defines a size range greater than or equal to min and less than or equal to max. It is used with CSS Grids.


Syntax:
minmax():
(200px, 1fr)
(400px, 50%)
(30%, 300px)
(100px, max-content)
(min-content, 400px)
(max-content, auto)
(auto, 300px)
(min-content, auto)
(200px, 1fr)
(30%, 300px)
(400px, 50%)
(50%, min-content)
(300px, max-content)
(200px, auto)\\ 
(400px, 50%)
(30%, 300px)
(min-content, 200px)
(max-content, 200px)
(auto, 300px)

*/