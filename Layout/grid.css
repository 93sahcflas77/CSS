/* css grid layout */
/* The CSS grid layout module excels at dividing a page into major regions or defining the relationship in terms of size, position, and layer, between parts of a control built from HTML primitives. */
/* Like tables, grid layout enables an author to align elements into columns and rows. For example, a grid container's child elements could position themselves so they actually overlap and layer, similar to CSS positioned elements. */


.wrapper{
    margin: 10px auto;
    text-align: center;
    max-width: 700px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    grid-auto-rows: minmax(100px , auto);
    border: 2px solid black;
    padding: 15px;
  }
  
  .wrapper > div{
    background-color: honeydew;
    border: 2px dotted black;
  }

  
/* Layering items with z-index */
/* Grid items can occupy the same cell, and in this case we can use the z-index property to control the order in which overlapping items stack. */
/* Controlling the order
We can control the order in which items stack up by using the z-index property - just like positioned items. If we give box2 a lower z-index than box1 it will display below box1 in the stack. */

.one{
    grid-column: 1 / 3;
    grid-row: 1;
    z-index: 1;
  }
  .Two{
    grid-column: 2 / 4;
    grid-row: 1 / 3;
    z-index: 2;
  }
  .Three{
    grid-column: 1 / 2;
    grid-row: 2 / 5;
  }
  .Four{
    grid-column: 3 / 4;
  }


  /* grid all 
____________properties________
display
grid-template-columns
grid-template-rows
grid-template-areas
grid-template
grid-auto-columns
grid-auto-rows
grid-auto-flow
grid
grid-row-start
grid-column-start
grid-row-end
grid-column-end
grid-row
grid-column
grid-area
row-gap
column-gap
gap

______________function_________
repeat()
minmax()
fit-content()
*/

/* grid track */
.wrapper1, .wrapper2, .wrapper3, .wrapper4{
  grid-auto-rows: minmax(100px , auto);
}

.wrapper1 > div , .wrapper2>div{
  background-color: black;
  color: white;
}

/* Basic concepts of grid layout */
/* CSS grid layout introduces a two-dimensional grid system to CSS. 
The features shown in this overview will then be explained in greater detail in the rest of this guide.

What is a grid?
A grid is a set of intersecting horizontal and vertical lines defining columns and rows.

CSS grid layout has the following features:

1. Fixed and flexible track sizes:  You can create a grid with fixed track sizes – using pixels for example. You can also create a grid using flexible sizes with percentages or with the fr unit designed for this purpose.

2. Item placement:  You can place items into a precise location on the grid using line numbers, names or by targeting an area of the grid. 

3. Creation of additional tracks to hold content:  You can define an explicit grid with grid layout. The Grid Layout specification is flexible enough to add additional rows and columns when needed. 

4. Alignment control:  Grid contains alignment features so we can control how the items align once placed into a grid area, and how the entire grid is aligned.

5. Control of overlapping content:  More than one item can be placed into a grid cell or area and they can partially overlap each other. This layering may then be controlled with the z-index property. */

/* Grid container
We create a grid container by declaring display: grid or display: inline-grid on an element. As soon as we do this, all direct children of that element become grid items.

In this example, I have a containing div with a class of wrapper and, inside are five child elements.All the direct children are now grid items. 

  selector{
      dispaly: grid;
  } */


.wrapper1{
  display: grid;
  gap: 10px;
}

/* Grid tracks
We define rows and columns on our grid with the grid-template-rows and grid-template-columns properties. These define grid tracks. 
A grid track is the space between any two adjacent lines on the grid. 
the grid-template-columns and grid-template-rows properties or the shorthand grid or grid-template properties. */
/* I can add to our earlier example by adding the grid-template-columns property, then defining the size of the column tracks.
I have now created a grid with three 200-pixel-wide column tracks.  */

.wrapper1{
  grid-template-columns: 200px 200px 200px;
}

/*The fr unit  
The new fr unit represents a fraction of the available space in the grid container. The next grid definition would create three equal width tracks that grow and shrink according to the available space.
*/

.wrapper1{
  grid-template-columns: 1fr 1fr 1fr;
}

/* Unequal sizes 
In this next example, we create a definition with a 2fr track then two 1fr tracks. The available space is split into four. Two parts are given to the first track and one part each to the next two tracks.
*/

.wrapper1{
  grid-template-columns: 1fr 2fr 1fr;
}


/* Mixing flexible and absolute sizes
The first track is 500 pixels, so the fixed width is taken away from the available space. The remaining space is divided into three and assigned in proportion to the two flexible tracks. */

.wrapper1{
    grid-template-columns: 800px 1fr 1fr;
}

/* Track listings with repeat() notation
Large grids with many tracks can use the repeat() notation, to repeat all or a section of the track listing. For example the grid definition:
  grid-templete-column:1fr 1fr 1fr; replaced (Can also be written as) grid-templete-column: repeat(3, 1fr); */


  .wrapper1{
    grid-template-columns: repeat(3, 1fr);
  }


/* In this next example I have created a grid with an initial 20-pixel track, then a repeating section of 6 1fr tracks then a final 20-pixel track.

.wrapper1{
  grid-template-columns: 20px repeat(6,1fr) 20px;
} */


/* In this next example, my grid will consist of 10 tracks, a 1fr track, and then followed by a 2fr track. This pattern will be repeated five times. */


.wrapper1{
  grid-template-columns: repeat(5, 1fr 2fr);
}


/* Implicit and explicit grids
If you place something outside of the defined grid—or due to the amount of content, more grid tracks are needed—then the grid creates rows and columns in the implicit grid. These tracks will be auto-sized by default, resulting in their size being based on the content that is inside them.

You can also define a set size for tracks created in the implicit grid with the grid-auto-rows and grid-auto-columns properties. */

/* In the below example, we use grid-auto-rows to ensure that tracks created in the implicit grid are 200 pixels tall. */

.wrapper1{
  grid-auto-rows: 200px;
}


/* Track sizing and minmax
For example, I may want my rows to never collapse smaller than 100 pixels, but if my content stretches to 300 pixels in height, then I would like the row to stretch to that height.
Grid has a solution for this with the minmax() function. */
/* In this next example I am using minmax() in the value of grid-auto-rows. */

.wrapper1{
  grid-auto-rows: minmax(200px, auto);
}

/* Grid lines
/* Grid then gives us numbered lines to use when positioning items. In our three column, two row grid we have four column lines.
Lines are numbered according to the writing mode of the document. In a left-to-right language, line 1 is on the left-hand side of the grid. (image show in thml line*/
/* Positioning items against lines
In the following example I am placing the first two items on our three column track grid, using the grid-column-start, grid-column-end, grid-row-start and grid-row-end properties.  */

/* example
the first item is placed against column line 1, and spans to column line 4, which in our case is the far-right line on the grid. It begins at row line 1 and ends at row line 3, therefore spanning two row tracks.

The second item starts on grid column line 1, and spans one track. This is the default so I do not need to specify the end line. It also spans two row tracks from row line 3 to row line 5.  */

.wrapper1{
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: 150px;

  max-width: 700px;
  margin: 0 auto;
}

.one-1{
  grid-column-start: 1;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
}

.Two-1{
  grid-column-start: 1;
  grid-row-start: 3;
  grid-row-end: 5;
}


/* Line-positioning shorthands
one line for columns with grid-column, and one line for rows with grid-row.
The value before the forward slash character (/) is the start line, the value after the end line. */

.one-1{
  grid-column: 1 / 4;
  grid-row: 1 / 3;
}

.Two-1{
  grid-column: 1;
  grid-row: 3 / 5;
}

.Five-1{
  grid-column: 2 / 4;
}

/* Grid cell:  A grid cell is the smallest unit on a grid. */

/*Grid areas:  Items can span one or more cells both by row or by column, and this creates a grid area. Grid areas must be rectangular. */

/* Gutters: Gutters or alleys between grid cells can be created using the column-gap and row-gap properties, or the shorthand gap. */
/* In the below example, I am creating a 10-pixel gap between columns and a 1em gap between rows.  */

.wrapper1{
  column-gap: 10px;
  row-gap: 2em;
}


/*Nesting grids  */

.one-1>div{
  margin: 20px;
   border: 2px solid #ffec99;
  border-radius: 5px;
  background-color: #fff9db;
  padding: 1em;
  color: black;
}

.one-1{
  display: grid;
  grid-template-columns: repeat(3 , 1fr);
}


/* Relationship of grid layout to other layout methods */

/* Grid and flexbox
Grid was designed for two-dimensional layout - rows, and columns at the same time
You have already learned how to use flexbox, the similarities should help you get to grips with Grid. */

/* 
One-dimensional versus two-dimensional layout

A simple example can demonstrate the difference between one- and two-dimensional layouts.
In this first example, I am using flexbox to lay out a set of boxes. I have five child items in my container, and I have given the flex properties values so that they can grow and shrink from a flex-basis of 150 pixels. I have also set the flex-wrap property to wrap
 */


.flexbox{
  margin-top: 10px;
  width: 600px;
  border: 1px solid black;
  padding: 10px;

  display: flex;
  flex-wrap: wrap;
}

.flexbox>div{
  flex: 1 1 150px;
  height: 50px;
  margin: 10px;
  background-color: blue;
  color: white;
}

/* In the image, you can see that two items have wrapped onto a new line. These items are sharing the available space and not lining up underneath the items above. This is because when you wrap flex items, each new row (or column when working by column) is an independent flex line in the flex container. Space distribution happens across the flex line. */

/* A common question then is how to make those items line up. This is where you want a two-dimensional layout method: You want to control the alignment by row and column, and this is where grid comes in. */

/* 
The same layout with CSS grids

In this next example, I create the same layout using Grid. This time we have three 1fr column tracks. We do not need to set anything on the items themselves; they will lay themselves out one into each cell of the created grid. As you can see they stay in a strict grid, lining up in rows and columns. With five items, we get a gap on the end of row two. */

.wrapper2{
  margin: 10px auto;
  max-width: 600px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}

/* A simple question to ask yourself when deciding between grid or flexbox is:

do I only need to control the layout by row or column – use a flexbox
do I need to control the layout by row and column – use a grid */


/* flexbox =>  they will work out their spacing based on their size and the available space on that line.
grid =>  You allow the auto-placement rules to place the items into the grid cells according to that strict grid. It is possible to create tracks that respond to the size of the content, however, they will also change the entire track. */

/* Box alignment */

/* which uses flexbox aleady done */
/* I have a container with three items inside. The wrapper min-height is set, so it defines the height of the flex container. I have set align-items on the flex container to flex-end so the items will line up at the end of the flex container. I have also set the align-self property on box1 so it will override the default and stretch to the height of the container and on box2 so it aligns to the start of the flex container. 
      .wrapper {
           display: flex;
          align-items: flex-end;
          min-height: 200px;
        }
      .box1 {
        align-self: stretch;
        }
        .box2 {
        align-self: flex-start;
        }

*/

/* Alignment in CSS Grids
This example uses a grid to create the same layout. This time we are using the box alignment properties as they apply to a grid layout. So we align to start and end rather than flex-start and flex-end. In the case of a grid layout, we are aligning the items inside their grid area. In this case that is a single grid cell, but it could be an area made up of several grid cells. 

          .wrapper {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            align-items: end;
            grid-auto-rows: 200px;
          }
          .box1 {
            align-self: stretch;
          }
          .box2 {
            align-self: start;
          }
*/

/* The fr unit and flex-basis
The fr unit works to assign a proportion of available space in the grid container to our grid tracks. The fr unit, when combined with the minmax() function can give us very similar behavior to the flex properties in flexbox while still enabling the creation of a layout in two dimensions. */


/* Auto-filling grid tracks */
/* We can use grid to create a similar effect to flexbox, while still keeping the content arranged in strict rows and columns, by creating our track listing using repeat notation and the auto-fill and auto-fit properties. */

/* In this next example, I have used the auto-fill keyword in place of an integer in the repeat notation and set the track listing to 200 pixels.

This means that grid will create as many 200 pixels column tracks as will fit in the container. */

.wrapper3>div{
  background-color: red;
}


.wrapper3{
  padding: 10px;
  border: 2px solid black;
  
  margin-top: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px,1fr));
  gap: 10px;
}


/* A flexible number of tracks */
/* This isn't quite the same as flexbox. 

 In the flexbox example, the items are larger than the 200 pixel basis before wrapping. We can achieve the same in grid by combining auto-fit and the minmax() function. 

In this next example, I create auto filled tracks with minmax. I want my tracks to be a minimum of 200 pixels, so I set the maximum to be 1fr. */

.wrapper4>div{
  background-color: red;
}


.wrapper4{
  padding: 10px;
  border: 2px solid black;
  
  margin-top: 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px,1fr));
  gap: 10px;
}

/* Grid and absolutely positioned elements and absolutely positioned elements*/
/* Grid interacts with absolutely positioned elements, which can be useful if you want to position an item inside a grid or grid area.  */


/* A grid container as containing block */
/* To make the grid container a containing block you need to add the position property to the container with a value of relative, just as you would make a containing block for any other absolutely positioned items.

In the below example I have a wrapper containing four child items. Item three is absolutely positioned and also placed on the grid using line-based placement. The grid container has position: relative and so becomes the positioning context of this item. */

.wrapper5{
  margin-top: 30px;
  display: grid;
  grid-template-columns: repeat(4,1fr);
  grid-auto-rows: 200px;
  gap: 10px;

  border: 2px solid black;
  position: relative;
}

.wrapper5>div{
  background-color: hotpink;
  border: 2px solid #dd0e72;
  padding: 20px;
  color: red;
}

.wrapper5 div:nth-child(3){
  grid-column: 2/5;
  grid-row: 1/3;

  position: absolute;
  top: 40px;
  left: 40px;
}

/* Using display: contents
If I now add display: contents to the rules for box1, the box for that item vanishes and the sub-items now become grid items and lay themselves out using the auto-placement rule */

.wrapper6 {
  margin-top: 25px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-auto-rows: minmax(100px, auto);
  gap: 20px;

  border: 2px solid yellowgreen;
  padding: 10px;
  background-color: whitesmoke;
}
.wrapper6>div{
  background-color: green;
}
.wrapper6 .box1 {
  grid-column-start: 1;
  grid-column-end: 4;
  display: contents;
}
.wrapper6 .box1 .nested{
  background-color: red;
  margin: 10px;
}

/* Grid layout using line-based placement */
/* The lines are numbered for columns and rows, and are indexed from 1. Note that grid is indexed according to the writing mode of the document. In a left to right language such as English line 1 is on the left-hand side of the grid. */

/* A basic example */
/* As a very simple example we can take a grid with 3 column tracks and 3 row tracks. This gives us 4 lines in each dimension. */

.wrapper7 > div{
  /* background-color: #be3979; */
  border-left: 3px dotted black;
  border-bottom: 3px dotted black;
}

.box{
  padding: 30px;
  border: 1px solid black;
  margin: 20px;
  position: relative;
}

.wrapper7{
  max-width: 700px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(3, minmax(20px , 1fr));
  grid-template-rows: repeat(3, minmax(100px, 120px));
  gap: 1.5px;
}

span:nth-child(2)::before{
  content: "1";
  position: absolute;
  top: 7px;
  left: 465px;
  font-size: 30px;
}
span:nth-child(3)::before{
  content: "2";
  position: absolute;
  top: 7px;
  left: 695px;
  font-size: 30px;
}
span:nth-child(4)::before{
  content: "3";
  position: absolute;
  top: 7px;
  left: 924px;
  font-size: 30px;
}
span:nth-child(5)::before{
  content: "4";
  position: absolute;
  top: 7px;
  left: 1156px;
  font-size: 30px;
}
span:nth-child(6)::before{
  content: "1";
  position: absolute;
  top: 25px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(7)::before{
  content: "2";
  position: absolute;
  top: 137px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(8)::before{
  content: "3";
  position: absolute;
  top: 262px;
  left: 443px;
  font-size: 30px;
}
span:nth-child(9)::before{
  content: "4";
  position: absolute;
  top: 384px;
  left: 443px;
  font-size: 30px;
}

/* Positioning items by line number */
/* We can use line-based placement to control where these items sit on the grid. We would like the first item to start on the far left of the grid and span a single column track.  */
.wrapper8 > div{
  /* background-color: #be3979; */
}

.wrapper8{
  max-width: 1100px;
  margin: 10px auto;
  display: grid;
  grid-template-columns: repeat(3, minmax(20px , 1fr));
  grid-template-rows: repeat(3, minmax(100px, 130px));
  border: 2px solid black;
}

.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: 1;
  grid-column-end: 2;
  grid-row-start: 1;
  grid-row-end: 4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: 2;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 2;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: 3;
  grid-column-end: 4;
  grid-row-start: 1;
  grid-row-end: 3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 3;
  grid-row-end: 4;
}

/* The grid-column and grid-row shorthands */
/* We have quite a lot of code here to position each item. It should come as no surprise to know there is a shorthand. The grid-column-start and grid-column-end properties can be combined into grid-column, grid-row-start and grid-row-end into grid-row. */
.wrapper8 div:nth-child(1){
  grid-column: 1 / 2;
  grid-row: 1 / 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2 / 3;
  grid-row: 1 / 2;
}
.wrapper8 div:nth-child(3){
  grid-column: 3 / 4;
  grid-row: 1 / 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / 4;
  grid-row: 3 / 4;
}

/* Default spans */
/* we specified every end row and column line, in order to demonstrate the properties, however in practice if an item only spans one track you can omit the grid-column-end or grid-row-end value. Grid defaults to spanning one track. */

/* Default spans with longhand placement */
.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: 1;
  grid-row-start: 1;
  grid-row-end: 4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: 2;
  grid-row-start: 1;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: 3;
  grid-row-start: 1;
  grid-row-end: 3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: 2;
  grid-column-end: 4;
  grid-row-start: 3;
}

/* Default spans with shorthand placement */
.wrapper8 div:nth-child(1){
  grid-column: 1 ;
  grid-row: 1 / 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2;
  grid-row: 1 / 2;
}
.wrapper8 div:nth-child(3){
  grid-column: 3;
  grid-row: 1 / 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / 4;
  grid-row: 3;
} 

/* The grid-area property
We can take things a step further and define each area with a single property – grid-area. The order of the values for grid-area are as follows.

grid-row-start
grid-column-start
grid-row-end
grid-column-end */

.wrapper8 div:nth-child(1){
  grid-area: 1 /1 /4 /2;
}

.wrapper8 div:nth-child(2){
  grid-area: 1 /2 / 2 / 3;
}
.wrapper8 div:nth-child(3){
  grid-area: 1 / 3 / 3 / 4;
}
.wrapper8 div:nth-child(4){
  grid-area: 3 / 2 / 4 / 4;
} 

/* We will explore how grids work with writing modes in a later article however we have the concept of four flow-relative directions:

block-start
block-end
inline-start
inline-end */


/* Counting backwards
We can also count backwards from the block and inline end of the grid, for English that would be the right-hand column line and final row line. These lines can be addressed as -1, and you can count back from there – so the second last line is -2. It is worth noting that the final line is the final line of the explicit grid, the grid defined by grid-template-columns and grid-template-rows, and does not take into account any rows or columns added in the implicit grid outside of that. */

.wrapper8 div:nth-child(1){
  background-color: red;
  grid-column-start: -1;
  grid-column-end: -2;
  grid-row-start: -1;
  grid-row-end: -4;
}
.wrapper8 div:nth-child(2){
  background-color: #dd0e72;
  grid-column-start: -2;
  grid-column-end: -3;
  grid-row-start: -1;
  grid-row-end: -2;
}
.wrapper8 div:nth-child(3){
  background-color: green;
  grid-column-start: -3;
  grid-column-end: -4;
  grid-row-start: -1;
  grid-row-end: -3;
}
.wrapper8 div:nth-child(4){
  background-color: #ffec99;
  grid-column-start: -2;
  grid-column-end: -4;
  grid-row-start: -3;
  grid-row-end: -4;
}

/* Using the span keyword
In addition to specifying the start and end lines by number, you can specify a start line and then the number of tracks you would like the area to span. */
.wrapper8 div:nth-child(1){
  grid-column: 1 ;
  grid-row: 1 / span 4;
}

.wrapper8 div:nth-child(2){
  grid-column: 2;
  grid-row: 1 ;
}
.wrapper8 div:nth-child(3){
  grid-column: 3;
  grid-row: 1 / span 3;
}
.wrapper8 div:nth-child(4){
  grid-column: 2 / span 4;
  grid-row: 3;
} 

/* You can also use the span keyword in the value of grid-row-start/grid-row-end and grid-column-start/grid-column-end. The following two examples will create the same grid area. In the first we set the start row line, then the end line we explain that we want to span 3 lines. The area will start at line 1 and span 3 lines to line 4.

.box1 {
  grid-column-start: 1;
  grid-row-start: 1;
  grid-row-end: span 3;
}


In the second example, we specify the end row line we want the item to finish at and then set the start line as span 3. This means the item will need to span upwards from the specified row line. The area will start at line 4 and span 3 lines to line 1.

.box1 {
  grid-column-start: 1;
  grid-row-start: span 3;
  grid-row-end: 4;
} */



/* Layout using named grid lines */
/* Naming lines when defining a grid */

/* You can assign some or all of the lines in your grid a name when you define your grid with the grid-template-rows and grid-template-columns properties. This time I'll create the grid using named lines. */


.item{
  color: rgb(31, 28, 28);
  font-size: 25px;
  
  display: flex;
  align-items: center;
  justify-content: center;
}

.container{
  margin: 0 auto;
  max-width: 900px;
  display: grid;

  /* Giving lines multiple names */
  /* You may want to give a line more than one name, perhaps it denotes the sidebar-end and the main-start for example. To do this add the names inside the square brackets with whitespace between them [sidebar-end main-start]. You can then refer to that line by either of the names. */

  /* grid-template-columns: repeat(3,1fr); */
  grid-template-columns: [one-start] 1fr [one-end two-start] 1fr [two-end three-start] 1fr [three-end four-start] 1fr [four-end];
  /* grid-template-rows:  120px 80px  100px 200px 110px 120px; */
  grid-template-rows: [header-start] 100px [header-end menu-start]  60px [menu-end box-start]  100px [box-end content-start]  200px [content-end footer-start] 130px [footer-end];
  gap: 10px;
}

.header1{
  background-color: red;
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: header-start;
  grid-row-end: header-end;
}
.menu1{
  background-color: greenyellow;
  /* grid-area: 2 / 1 / 3 / 4; */
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: menu-start;
  grid-row-end: menu-end;
}
.box1{
  background-color: rgb(40, 40, 153);
  /* grid-area: 3 / 1 / 4 / 2; */
  grid-column-start: one-start;
  grid-column-end: one-end;
  grid-row-start: box-start;
  grid-row-end: box-end;
}
.box2{
  background-color: rgb(187, 69, 89);
  /* grid-area: 3 / 2 / 4 / 3; */
  grid-column-start: two-start;
  grid-column-end: two-end;
  grid-row-start: box-start;
  grid-row-end: box-end;
}
.sidebar1{
  background-color: darkblue;
  /* grid-area: 3 / 3 / 6 / 4; */
  grid-column-start: three-start;
  grid-column-end: four-end;
  grid-row-start: box-start;
  grid-row-end: content-end;
}
.content1{
  background-color: rgb(20, 187, 216);
  /* grid-area: 4 / 1 / 6 / 3; */
  grid-column-start: one-start;
  grid-column-end: two-end;
  grid-row-start: content-start;
  grid-row-end: content-end;
}
.footer1{
  background-color: gray;
  /* grid-area: 6 / 1 / 7 / 4; */
  grid-column-start: one-start;
  grid-column-end: four-end;
  grid-row-start: footer-start;
  grid-row-end: footer-end;
}


/* Implicit Grid lines from named areas */
/* If we take the layout created in the guide to Grid Template Areas, we can use the lines created by our areas to see how this works. */
/* In this example I have added an extra div with a class of overlay. We have named areas created using the grid-area property, then a layout created in grid-template-areas.  */

/* The area names are: 'hd' 'ft' 'main' 'sd'
This gives us column and row lines: 'hd-start' 'hd-end' 'ft-start' 'ft-end' 'main-start' 'main-end' 'sd-start' 'sd-end' */


.container1{
  margin: 10px auto;
  max-width: 900px;
  border: 2px solid black;
  display: grid;

  grid-template-columns: repeat(10 ,1fr);
  grid-template-rows: repeat(3, minmax(120px , auto));

  grid-template-areas: 
      'hd hd hd hd hd hd hd hd hd hd'
      'ft ft ft ft main main main main main main'    
      'sd sd sd sd sd sd sd sd sd sd'
  ;
}

.container1 > .item{
  background-color: #dd0e72;
}
.container1 .overlay{
  z-index: 10;
  grid-column: ft-start / ft-end;
  grid-row: ft-start / sd-end;
  border: 4px solid rgb(92, 148, 13);
  background-color: rgba(92, 148, 13, 0.4);
  color: red;
  font-size: 150%;

  display: flex;
  justify-content: center;
}
.header2{
  grid-area: hd;
  border-bottom: 2px solid white;
}
.sidebar2{
  grid-area: ft;
  border-bottom: 2px solid white;
  border-right: 2px solid white;
}
.content2{
  grid-area: main;
  border-bottom: 2px solid white;
}
.footer2{
  grid-area: sd;
}


/* Multiple lines with the same name with repeat() */

/* Twelve-column grid using repeat() */
/* I am creating a grid with twelve equal width columns. Before defining the 1fr size of the column track I am also defining a line name of [col-start]. This means that we will end up with a grid that has 12 column lines all named col-start before a 1fr width column. */


.wrapper10 > .item{
  background-color: #fff9db;
}

.wrapper10{
  margin: 10px auto;
  border: 2px solid black;

  display: grid;
  grid-template-columns: repeat(12, [col-start] 1fr);
}

/* To place our item from the first line named col-start to the 5th */
.box3{
  grid-column: col-start / col-start 5;
}

/* You can also use the span keyword here. My next item will be placed from the 7th line named col-start and span 3 lines. */
.box4{
  grid-column: col-start 7 / span 3;
}


/* Defining named lines with a track list */

/* The code below would create an eight track grid, with a narrower 1fr width column named col1-start followed by a wider 3fr column named col2-start. */

/* .selector{
  grid-template-columns: repeat(4, [col1-start] 1fr [col2-start] 3fr);
} */

/* If your repeating syntax puts two lines next to each other then they will be merged, and create the same result as giving a line multiple names in a non-repeating track definition. The following definition, creates four 1fr tracks, which each have a start and end line. */

/* .selector{
  grid-template-columns: repeat(4, [col-start] 1fr [col-start]);
} */

/* If we write this definition out without using repeat notation it would look like this. */
/* .selector{
  grid-template-columns: [col-start] 1fr [col-end col-start] 1fr [col-end col-start] 1fr [col-end col-start] 1fr [col-end];
} */


/* Grid template areas */
/* This method involves placing our items using named template areas, and we will find out exactly how this method works. You will see very quickly why we sometimes call this the ascii-art method of grid layout! */

/* Naming a grid area */
/* You have already encountered the grid-area property. This is the property that can take as a value all four of the lines used to position a grid area. */

/* selector{
  grid-area: 1 / 1 / 4 / 2;
} */

/* We can also define an area by giving it a name and then specify the location of that area in the value of the grid-template-areas property. You can choose what you would like to name your area. For example, if I wish to create the layout shown below I can identify four main areas.

a header
a footer
a sidebar
the main content */

/* With the grid-area property I can assign each of these areas a name. */

.wrapper9 > div{
  background-color: #ffec99;
}

.wrapper9{
  display: grid;
  grid-template-columns: repeat(9, 1fr);
  grid-template-rows: repeat(3,200px);
  gap: 5px;
  max-width: 900px;
 margin: 0 auto;
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    "ft ft ft ft ft ft ft ft ft"
  ;

}
.header{
  grid-area: hd;
}
.sidebar{
  grid-area: sd;
}
.content{
  grid-area: ct;
}
.footer{
  grid-area: ft;
}

/* Leaving a grid cell empty */
/* To leave a cell empty use the full stop character, '.'. */
.wrapper9{
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    ". . . ft ft ft ft ft ft"
    ;
}

/* Spanning multiple cells */
/* The area that you create by chaining the area names must be rectangular, at this point there is no way to create an L-shaped area. The specification does note that a future level might provide this functionality. You can however span rows just as easily as columns. For example we could make our sidebar span down to the end of the footer by replacing the . with sd. */

.wrapper9{
  grid-template-areas: 
    "hd hd hd hd hd hd hd hd hd"
    "sd sd sd ct ct ct ct ct ct" 
    "sd sd sd ft ft ft ft ft ft"
    ;  
}


/* Redefining the grid using media queries */
/* the names for your areas outside of any media queries. That way the content area would always be called main no matter where on the grid it is placed. */

.wrapper9{
  grid-template-areas: 
    "hd"
    "sd" 
    "ct"
    "ft"
    ;  
}

/* media queries */
@media (min-width: 500px) {
  .wrapper9 {
    grid-template-columns: repeat(9, 1fr);
    grid-template-areas:
      "hd hd hd hd   hd   hd   hd   hd   hd"
      "sd sd sd ct ct ct ct ct ct"
      "sd sd sd  ft  ft   ft   ft   ft   ft";
  }
}
@media (min-width: 700px) {
  .wrapper9 {
    grid-template-areas:
      "hd hd hd   hd   hd   hd   hd   hd hd"
      "sd sd ct ct ct ct ct ft ft";
  }
}
